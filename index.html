<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Wordle Junior</title>
    <meta
      name="description"
      content="A kid-friendly version of the popular Wordle game"
    />

    <meta
      property="og:url"
      content="https://canadianveggie.github.io/wordle-junior/"
    />
    <meta property="og:type" content="website" />
    <meta
      property="og:title"
      content="Wordle Junior - A daily word game for kids"
    />
    <meta
      property="og:description"
      content="Tricking kids into learning to spell since 2022"
    />
    <!-- <meta
      property="og:image"
      content="TODO.png"
    /> -->

    <script src="//unpkg.com/alpinejs" defer></script>
    <link href="./public/main.css" rel="stylesheet" />
  </head>

  <body>
    <main>
      <h1 class="title">Wordle Junior</h1>
      <div
        class="game-content"
        x-data="gameState()"
        @keyup.document="keyPressed"
      >
        <div class="guesses">
          <template x-for="(guess, guess_index) in guesses">
            <div class="guesses-word">
              <template x-for="(letter, letter_index) in guess">
                <div
                  class="guesses-tile"
                  :class="[letter.state, isCursor(guess_index, letter_index) ? 'cursor' : '']"
                  @click="selectTile(guess_index, letter_index)"
                >
                  <span
                    x-show="letter.letter"
                    x-text="letter.letter"
                    x-transition:enter="pop"
                  ></span>
                </div>
              </template>
            </div>
          </template>
        </div>
        <div class="keyboard">
          <div
            x-show="solved"
            x-cloak
            x-transition.duration.1000ms
            class="victory"
          >
            <span class="emoji" x-text="victoryEmoji"></span> You win!
          </div>
          <div
            x-cloak
            x-show="failed"
            x-transition.duration.1000ms
            class="defeat"
          >
            Nice try!
            <p x-text="target"></p>
          </div>
          <template x-if="!solved && !failed">
            <template x-for="letter in keyboard">
              <div
                class="key"
                x-text="letter.label"
                :class="['key-' + letter.type, letter.state]"
                @click="addLetter(letter)"
              ></div>
            </template>
          </template>
        </div>
      </div>
    </main>
  </body>

  <script src="public/puzzles.js"></script>
  <script>
    const target = getTodayPuzzle();
    const maxGuesses = 6;

    const a_z = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
    const keyboard = a_z.map((letter) => ({
      type: "letter",
      label: letter,
      state: "available",
    }));
    keyboard.push({
      type: "back",
      label: "‚Üê",
      state: "unavailable",
    });
    keyboard.push({
      type: "enter",
      label: "guess",
      state: "unavailable",
    });
    const guesses = [];
    for (let i = 0; i < maxGuesses; i++) {
      const guess = [];
      for (let j = 0; j < target.length; j++) {
        guess.push({ letter: "", state: "pending" });
      }
      guesses.push(guess);
    }

    let initialState = {};
    try {
      initialState = JSON.parse(localStorage.getItem("game-state") || "{}");
      if (initialState.target !== target) {
        // Don't use yesterday's state
        initialState = {};
      }
    } catch (err) {
      console.error(err);
    }

    function gameState() {
      return {
        target,
        guesses: initialState.guesses || guesses,
        solved: initialState.solved || false,
        failed: initialState.failed || false,
        currentGuessIndex: initialState.currentGuessIndex || 0,
        cursor: initialState.cursor || 0,
        cursorMode: initialState.cursorMode || false,
        keyboard: initialState.keyboard || keyboard,
        addLetter(letterState) {
          if (this.solved || this.failed) {
            return;
          }
          if (letterState.type === "enter") {
            if (this.isCurrentWordComplete()) {
              this.currentGuess.forEach(
                (letterGuess) => (letterGuess.state = "submitted")
              );
              this.checkAnswer();
              if (!this.solved && !this.failed) {
                this.currentGuessIndex += 1;
                this.cursor = 0;
              }
              this.updateControls();
              this.saveGameState();
            }
          } else if (letterState.type === "back") {
            const deleteIndex = this.cursorMode ? this.cursor : this.cursor - 1;
            if (deleteIndex >= 0) {
              this.currentGuess[deleteIndex].letter = "";
              this.cursor = Math.max(0, this.cursor - 1);
              this.updateControls();
            }
          } else if (letterState.type === "letter") {
            if (this.cursor < this.currentGuess?.length) {
              this.currentGuess[this.cursor].letter =
                letterState.label.toUpperCase();
              this.cursor += 1;
              this.updateControls();
            }
          }
        },
        checkAnswer() {
          const result = compareTargetAndGuess(this.target, this.currentWord);
          result.forEach((letterResult, i) => {
            this.currentGuess[i].state = letterResult;
            this.updateKeyboard(this.currentWord[i], letterResult);
          });
          this.solved = this.currentWord === this.target;
          if (
            !this.solved &&
            this.currentGuessIndex >= this.guesses.length - 1
          ) {
            this.failed = true;
          }
        },
        updateKeyboard(label, state) {
          const key = this.keyboard.find((letter) => letter.label === label);
          // Don't overwrite hit or present with miss
          if (
            key.state === "hit" ||
            (key.state === "present" && state === "miss")
          ) {
            return;
          }
          key.state = state;
        },
        updateControls() {
          const backKey = this.keyboard.find(
            (letter) => letter.type === "back"
          );
          const enterKey = this.keyboard.find(
            (letter) => letter.type === "enter"
          );
          backKey.state = this.cursor > 0 ? "available" : "unavailable";
          enterKey.state = this.isCurrentWordComplete()
            ? "available pulse"
            : "unavailable";
        },
        keyPressed(e) {
          if (e.key === "Enter") {
            this.addLetter({ type: "enter" });
            this.cursorMode = false;
          } else if (e.key === "Backspace") {
            this.addLetter({ type: "back" });
          } else if (e.key === "ArrowLeft") {
            this.cursor = Math.max(0, this.cursor - 1);
            this.cursorMode = true;
          } else if (e.key === "ArrowRight") {
            this.cursor = Math.min(this.target.length - 1, this.cursor + 1);
            this.cursorMode = true;
          } else if (e.key === "?") {
            // TODO
            console.log("Give a hint or show help");
          } else if (
            /^[a-zA-Z]$/.test(e.key) &&
            !e.altKey &&
            !e.ctrlKey &&
            !e.metaKey
          ) {
            this.addLetter({ type: "letter", label: e.key });
            this.cursorMode = false;
          }
        },
        selectTile(guess_index, letter_index) {
          if (!this.solved && guess_index === this.currentGuessIndex) {
            this.cursor = letter_index;
            this.cursorMode = true;
          }
        },
        get currentGuess() {
          return this.guesses[this.currentGuessIndex];
        },
        get currentWord() {
          return this.currentGuess
            ?.map((letterGuess) => letterGuess.letter || " ")
            .join("");
        },
        isCurrentWordComplete() {
          return (
            this.currentWord?.length === this.target.length &&
            this.currentWord.indexOf(" ") < 0
          );
        },
        isCursor(guess_index, letter_index) {
          return (
            guess_index === this.currentGuessIndex &&
            letter_index === this.cursor
          );
        },
        get victoryEmoji() {
          const emojis = ["üèÜ", "ü§©", "ü•≥", "üòÅ", "üôÇ", "üëç"];
          return emojis[this.currentGuessIndex ?? 5];
        },
        saveGameState() {
          localStorage.setItem("game-state", JSON.stringify(this.toJson()));
        },
        toJson() {
          return {
            target: this.target,
            guesses: this.guesses,
            solved: this.solved,
            failed: this.failed,
            currentGuessIndex: this.currentGuessIndex,
            cursor: this.cursor,
            cursorMode: this.cursorMode,
            keyboard: this.keyboard,
          };
        },
      };
    }
  </script>
</html>
